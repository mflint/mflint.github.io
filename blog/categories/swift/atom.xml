<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Matthew's Dev Blog]]></title>
  <link href="http://daringsnowball.net/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://daringsnowball.net/"/>
  <updated>2018-11-23T13:25:05+00:00</updated>
  <id>http://daringsnowball.net/</id>
  <author>
    <name><![CDATA[Matthew Flint]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Extensions for Protocol Conformance Considered Harmful]]></title>
    <link href="http://daringsnowball.net/swift-extensions-for-protocol-conformance-considered-harmful/"/>
    <updated>2018-11-23T12:11:43+00:00</updated>
    <id>http://daringsnowball.net/swift-extensions-for-protocol-conformance-considered-harmful</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve come to the conclusion that using Swift extensions to make types conform to protocols is rather an anti-pattern. Let me explain why.</p>

<!-- more -->


<h3>How extensions can be useful</h3>

<p>Swift type extensions are amazing for adding extra functionality to existing types if the following two conditions are true:</p>

<ol>
<li>you don&rsquo;t own the type</li>
<li>you could reasonably argue that the functionality is <em>missing</em> from that type</li>
</ol>


<p>Example: if we wanted to url-encode a string (<code>Hello world</code> would become <code>Hello%20World</code>), we might do this by extending the <code>String</code> type:</p>

<pre><code>extension String {
    func urlEncode() -&gt; String {
        // implementation here
    }
}
</code></pre>

<p>However, if you already own the type, then I&rsquo;d argue that you should simply add the new functionality to the type itself.</p>

<p>Also, if your new functionality is <em>very specific to the app you&rsquo;re writing</em>, then an extension probably isn&rsquo;t appropriate. Example: your app has a set of railway stations which can be identified by a string &lsquo;reference code&rsquo;. You might consider adding an extension like this, to get the model for a given code:</p>

<pre><code>// don't do this
extension String {
    func stationModel() -&gt; StationModel {
        // implementation here
    }
}

let aslocktonStation = "ALK".stationModel()
</code></pre>

<p>No, don&rsquo;t do that. A Swift <code>String</code> doesn&rsquo;t care about your app.</p>

<h3>Three main problems with extensions for protocol conformance</h3>

<p>However I do object to using extensions for protocol conformance:</p>

<ol>
<li>extensions alter the <em>public interface</em> for the extended type, which breaks encapsulation (exposing the internal workings of that type), and is ripe for abuse by future lazy devs</li>
<li>it&rsquo;s really easy to lose code when relying on extensions everywhere</li>
<li>type-safety can be damaged</li>
</ol>


<h3>Public interface changes</h3>

<p>Here&rsquo;s an example of a class which is interested in receiving messages from a paired WatchKit app:</p>

<pre><code>extension ViewController: WCSessionDelegate {
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        self.myData = self.parse(incomingMessage: message)
        self.updateUI()
    }
}
</code></pre>

<p>This will work OK, but now <code>WCSessionDelegate</code> is part of the public interface of this <code>ViewController</code> class. Our ViewController&rsquo;s WatchKit dependency is now there for everyone to see (and possibly abuse).</p>

<p>Somebody, eventually, will be tempted call these delegate functions directly:</p>

<pre><code>let session: WCSession? = nil
myViewController.session(session!, didReceiveMessage: ["foo": "bar"])
</code></pre>

<p>A nicer alternative solution, which was common in my Java days, would be to make a private internal type which conforms to the delegate protocol:</p>

<pre><code>class ViewController: UIViewController {
    private class MessageHandler: NSObject, WCSessionDelegate {
        private weak var viewController: ViewController?

        init(viewController: ViewController) {
            self.viewController = viewController
        }

        func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
            viewController.accept(message)
        }
    }

    private var messageHandler: MessageHandler?

    override func viewDidLoad() {
        messageHandler = MessageHandler(viewController: self)
        watchSession.delegate = messageHandler
    }

    private func accept(_ incomingMessage: [String : Any]) {
        myData = parse(incomingMessage: message)
        updateUI()
    }
}
</code></pre>

<p>With this solution, the WatchKit dependency is hidden and the delegate functions aren&rsquo;t exposed in the public interface for the class.</p>

<h3>Losing code in extensions</h3>

<p>I&rsquo;m a firm believer in having one unambiguous place to put a piece of code, and that code should be easy to find. Unfortunately, when using extensions for protocol conformance, code can get lost.</p>

<p>In my <em>Nearly Departed</em> app rewrite, I have sets of <code>Model</code> objects which contain data received from an API, and some <code>ViewModel</code> protocols which format that data for presentation on-screen.</p>

<p>Simplified example:</p>

<pre><code>struct DepartureModel {
    var destination: String
    var departureTime: String
}

protocol DepartureViewModel {
    func departureDescription() -&gt; String
}

extension DepartureModel: DepartureViewModel {
    func departureDescription() -&gt; String {
        return "\(departureTime) to \(destination)"
    }
}
</code></pre>

<p>So the <code>departureDescription()</code> func might return something like &ldquo;18:05 to Nottingham&rdquo;.</p>

<p>This felt like a fabulous idea, which I embraced - but now I struggle to find those extensions. (Admittedly this is made more difficult because I have targets for an iOS app, a Today extension and a WatchKit extension)</p>

<p>It&rsquo;s so difficult to use that I&rsquo;m starting to rewrite these parts with a separate concrete <code>DepartureViewModel</code> class, which holds a reference to the <code>DepartureModel</code>:</p>

<pre><code>struct DepartureViewModel {
    let departure: DepartureModel

    func departureDescription() -&gt; String {
        return "\(departure.departureTime) to \(departure.destination)"
    }
}
</code></pre>

<p>Yes, preferring composition over interitance is still just as relevant in 2018 - and conformance-via-extensions feels similar to &ldquo;inheritance&rdquo; to me.</p>

<h3>Type-safety implications</h3>

<p>I found that I was writing code like this:</p>

<pre><code>guard let viewModel = model as? DepartureViewModel else {
    // ooh crikey, what now?
    preconditionFailure()
}

label.text = viewModel.departureDescription()
</code></pre>

<p>Not. Pretty. At. All.</p>

<p>I&rsquo;d favour compile-time failures over runtime crashes every time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling widgetPerformUpdate in an iOS Today extension]]></title>
    <link href="http://daringsnowball.net/handling-widgetperformupdate-in-an-ios-today-extension/"/>
    <updated>2018-11-10T12:59:02+00:00</updated>
    <id>http://daringsnowball.net/handling-widgetperformupdate-in-an-ios-today-extension</id>
    <content type="html"><![CDATA[<p>Apple&rsquo;s documentation about the <code>NCWidgetProviding</code> protocol, and <code>widgetPerformUpdate:</code> function in particular are rather sparse, and most posts on StackOverflow seem to have a very simplistic view about how this callback should be coded. So here are my tips.</p>

<!-- more -->


<p>Most examples you&rsquo;ll see for <code>widgetPerformUpdate:</code> look rather like this:</p>

<pre><code>func widgetPerformUpdate(completionHandler: (@escaping (NCUpdateResult) -&gt; Void)) {
    let resultModel = performExpensiveNetworkOperation()
    label.text = resultModel.someValue
    completionHandler(NCUpdateResult.newData)
}
</code></pre>

<p>&hellip; which would probably be OK, most of the time, but there are very few examples of expensive work being done asynchronously.</p>

<p>There are, however, three <em>big</em> hints that this is the right thing to do:</p>

<ol>
<li>Apple&rsquo;s documentation says <em>&ldquo;It&rsquo;s expected that the widget will perform the work to update asynchronously and off the main thread as much as possible&rdquo;</em>. (The <code>widgetPerformUpdate:</code> call does indeed arrive on the main thread)</li>
<li>the <code>completionHandler</code> block is annotated <code>@escaping</code>, implying that it will outlive the scope of the <code>widgetPerformUpdate:</code> function itself</li>
<li>the function returns <code>Void</code>; if this were intended to be a <em>blocking</em> call, then the func would simply have an <code>NCUpdateResult</code> return value instead of providing a completion block</li>
</ol>


<h3>Doing it right</h3>

<p>The correct way to do this depends on whether your long-running operation is synchronous (blocking), or asychronous with a completion block, or asynchronous with a delegate. Here are examples of all three.</p>

<h4>Performing a synchronous (blocking) operation</h4>

<pre><code>class SynchronousCallExampleViewController: UIViewController, NCWidgetProviding {
    private let dataSource = DataSource()
    private var data: Data?

    private func updateUI() {
        DispatchQueue.main.async {
            // update UI components
        }
    }

    func widgetPerformUpdate(completionHandler: @escaping (NCUpdateResult) -&gt; Void) {
        DispatchQueue.global().async {
            // fetch data on a background thread
            self.data = self.dataSource.fetchData()
            self.updateUI()
            completionHandler(.newData)
        }
    }
}
</code></pre>

<h4>Performing an asynchronous operation with a completion block</h4>

<pre><code>class AsynchronousCallWithCompletionBlockExampleViewController: UIViewController, NCWidgetProviding {
    private let dataSource = DataSource()
    private var data: Data?

    private func updateUI() {
        DispatchQueue.main.async {
            // update UI components
        }
    }

    func widgetPerformUpdate(completionHandler: @escaping (NCUpdateResult) -&gt; Void) {
        DispatchQueue.global().async {
            // fetch data on a background thread
            self.dataSource.fetchDataAsync({ [weak self] (data) in
                guard let self = self else { return }

                self.data = data
                self.updateUI()
                completionHandler(.newData)
            })
        }
    }
}
</code></pre>

<h4>Performing an asynchronous operation with a delegate callback</h4>

<pre><code>class AsynchronousCallWithDelegateExampleViewController: UIViewController, NCWidgetProviding, DataSourceDelegate {
    private var dataSource = DataSource()
    private var widgetCompletionHandler: ((NCUpdateResult) -&gt; Void)?
    private var data: Data?

    private func updateUI() {
        DispatchQueue.main.async {
            // update UI components
        }
    }

    func widgetPerformUpdate(completionHandler: @escaping (NCUpdateResult) -&gt; Void) {
        widgetCompletionHandler = completionHandler

        dataSource.delegate = self
        DispatchQueue.global().async {
            // fetch data on a background thread
            self.dataSource.fetchDataAsync()
        }
    }

    func dataDidUpdate(dataSource: DataSource) {
        data = dataSource.data
        updateUI()

        if let completionHandler = widgetCompletionHandler {
            completionHandler(.newData)
            widgetCompletionHandler = nil
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enums are meant for switching]]></title>
    <link href="http://daringsnowball.net/enums-are-meant-for-switching/"/>
    <updated>2018-11-03T09:00:16+00:00</updated>
    <id>http://daringsnowball.net/enums-are-meant-for-switching</id>
    <content type="html"><![CDATA[<p>I&rsquo;m rewriting <em>Nearly Departed</em>, and working on a large iOS project in my day-job. While working on both of those projects, I&rsquo;ve started to rely on two unofficial rules for enumerations:</p>

<ol>
<li>Enumeration values should always be checked with <code>switch</code>, not <code>if</code></li>
<li><code>default:</code> cases in <code>switch</code> statements are bad</li>
</ol>


<!-- more -->


<p>My reason for this is that <code>switch</code> statements without <code>default:</code> cases make the intent of the code explicit; we can be sure when reading code that the developer has properly considered every case.</p>

<p><em>As an extra bonus</em>, you&rsquo;ll now get a compile-time warning (or error, if &ldquo;treat warnings as errors&rdquo; is enabled) if more cases are ever added to the enumeration. This isn&rsquo;t as uncommon as you might think - Apple added a new case <code>.provisional</code> to the <code>UNAuthorizationStatus</code> enumeration in the iOS 12 SDK.</p>

<p>It&rsquo;s too early to have seen any real benefits from doing this (other than annoyed colleagues after I&rsquo;ve reviewed their pull requests) but I&rsquo;m <em>sure</em> we&rsquo;ll be glad of it sometime in the future.</p>

<h3>Exceptions to these rules</h3>

<p>In unit-test code, I wouldn&rsquo;t insist on <code>switch</code>ing over an enumeration. It&rsquo;s quite valid to do this when asserting the result of some operation:</p>

<pre><code>guard case let MyEnumeration.firstCase(myValue) = someResult else {
    XCTFail("Expected a 'firstCase' but got \(someResult) instead")
    return
}

XCTAssertEqual(myValue, "expected value")
</code></pre>

<h3>Extra bonus half-rule with no explanation</h3>

<p>An enumeration with more than ten values is a code-smell.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Nearly Departed (part 4: storage and sync)]]></title>
    <link href="http://daringsnowball.net/nearly-departed-rewrite-storage-and-sync/"/>
    <updated>2017-12-23T22:16:29+00:00</updated>
    <id>http://daringsnowball.net/rewriting-nearly-departed-storage-and-sync</id>
    <content type="html"><![CDATA[<p>This post gives an overview about how <em>Nearly Departed</em> Routes are stored and synced between iPhone and Apple Watch.</p>

<!-- more -->


<blockquote><p>This is part 4 of a multi-part series:</p>

<ul>
<li><a href="/nearly-departed-rewrite-intro/">Part 1</a>: intro</li>
<li><a href="/nearly-departed-rewrite-tech-background/">Part 2</a>: tech background</li>
<li><a href="/nearly-departed-rewrite-plans/">Part 3</a>: rewrite plans</li>
<li>Part 4: storage and sync</li>
</ul>
</blockquote>

<h3>Route storage</h3>

<p>Routes are stored in <code>UserDefaults</code> on the iPhone, and shared with the Watch using <em>WatchConnectivity</em>. To keep things simple, I have a <code>Storing</code> protocol for storing preferences and two implementations - one for the iPhone and one for the Watch.</p>

<p>The iPhone implementation stores preferences in <code>UserDefaults</code> and also sends things to the Watch. The Watch implementation simply talks to its counterpart on the iPhone.</p>

<p>After some experimentation (and help from <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/WatchKitProgrammingGuide/SharingData.html">Apple&rsquo;s WatchConnectivity documentation</a> and <a href="https://kristina.io/watchos-2-how-to-communicate-between-devices-using-watch-connectivity/">Kristina Fox&rsquo;s blog</a>), I settled on this communication strategy:</p>

<blockquote><ul>
<li><p>When the Watch app first starts, it requests the current preferences by sending a &ldquo;get&rdquo; command to the iPhone via <em>Interactive Messaging</em>:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">session</span><span class="p">.</span><span class="n">sendMessage</span><span class="p">([</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">cmd</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="kr">get</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;],</span> <span class="nl">replyHandler</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>  <span class="c1">// handle reply from phone</span>
</span><span class='line'><span class="p">})</span> <span class="p">{</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>  <span class="c1">// handle error</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>If preferences change on the iPhone, it sends data to the Watch by updating the <em>Application Context</em>:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// prefs is [String : Any]</span>
</span><span class='line'><span class="n">session</span><span class="p">.</span><span class="n">updateApplicationContext</span><span class="p">(</span><span class="n">prefs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>If preferences change on the Watch, it sends data to the iPhone using <em>Interactive Messaging</em>:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// prefs is [String : Any]</span>
</span><span class='line'><span class="n">session</span><span class="p">.</span><span class="n">sendMessage</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="nl">replyHandler</span><span class="p">:</span> <span class="nb">nil</span><span class="p">,</span> <span class="nl">errorHandler</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>  <span class="c1">// handle error</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</blockquote>

<p>This strategy seems to work well; both <em>Application Context</em> and <em>Interactive Messaging</em> work reliably, and quickly. (I&rsquo;m testing with iOS 11.2 and WatchOS 4.2)</p>

<h3>Phone dependence</h3>

<p>This means that the Watch app doesn&rsquo;t store any preferences locally, but instead gets preferences from the iPhone every time the Watch app starts. This is fine for now, but will be a problem when cellular Watches are more common. I&rsquo;ll make a change in the future to store preferences locally on the Watch, so the app can start without a nearby phone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting Nearly Departed (part 3: rewrite plans)]]></title>
    <link href="http://daringsnowball.net/nearly-departed-rewrite-plans/"/>
    <updated>2017-12-12T01:26:14+00:00</updated>
    <id>http://daringsnowball.net/rewriting-nearly-departed-rewrite-plans</id>
    <content type="html"><![CDATA[<p>So here&rsquo;s my plan for this rewrite of <em>Nearly Departed</em>.</p>

<!-- more -->


<blockquote><p>This is part 3 of a multi-part series:</p>

<ul>
<li><a href="/nearly-departed-rewrite-intro/">Part 1</a>: intro</li>
<li><a href="/nearly-departed-rewrite-tech-background/">Part 2</a>: tech background</li>
<li>Part 3: rewrite plans</li>
<li><a href="/nearly-departed-rewrite-storage-and-sync/">Part 4</a>: storage and sync</li>
</ul>
</blockquote>

<h3>Goals</h3>

<ul>
<li>Rewrite in Swift</li>
<li>&hellip; in a <em>Swifty</em> way</li>
<li>With a decent set of unit tests</li>
<li>Same features as the existing app:

<ul>
<li>departure boards (all departures from a station)</li>
<li>station alerts (problems with services in this area)</li>
<li>service alerts (problems with this particular service)</li>
</ul>
</li>
<li>New features:

<ul>
<li>Show service details (the progress of an individual service during its journey)</li>
<li>Reinstate Apple Watch support</li>
<li>Architect the code so it wouldn&rsquo;t be impossible to add different datasources in the future</li>
</ul>
</li>
</ul>


<h3>Non-goals</h3>

<ul>
<li>Making money - this is primarily a learning exercise</li>
</ul>


<h3>Branching strategy</h3>

<p>My git branching strategy is slightly unusual because I want to actually use the app daily while it&rsquo;s being developed, but I also want to maintain code quality and decent test coverage.</p>

<dl>
<dt>master branch</dt>
<dd>this is the nice well-tested branch</dd>
<dt>ui-spike branch</dt>
<dd>this is the hacky branch, where code is tweaked to make things work. <code>master</code> is regularly merged into <code>ui-spike</code>, but not the other way around</dd>
</dl>

<h3>Using Laurine for localisation</h3>

<p>I&rsquo;ve used <a href="https://github.com/JiriTrecak/Laurine/">Laurine</a> in <a href="https://itunes.apple.com/us/app/tldt-pages/id1071725095?ls=1&amp;mt=8">another app</a> with great success - and wanted to use it again here.</p>

<p>You define your <code>Localizble.strings</code> file as normal:</p>

<p><figure class='code'><figcaption><span>Localizable.strings </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">PLATFORM_NUMBER</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Platform</span> <span class="o">%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>and then Laurine generates a new <code>Localizations</code> swift file, which you can use like this:</p>

<p><figure class='code'><figcaption><span>Localizations.swift </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">Localizations</span><span class="p">.</span><span class="n">PLATFORM_NUMBER</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="mi">4</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>Frameworks</h3>

<p>Nope.</p>

<p>It all sounds great - putting common code in a framework which is then shared between the iPhone app / widget / Watch App targets. But it never works out well.</p>

<h3>Data models</h3>

<p><strong>We&rsquo;ll start by talking about <em>Routes</em>.</strong> A route provides data for a request, and is user-defined in one of two ways:</p>

<ol>
<li>Explicitly, via the iOS app. (example: all departures from York to Leeds would be an instance of <code>DarwinDeparturesRoute</code>)</li>
<li>Implicitly, from another route. (example: when viewing departures from York to Leeds, they might tap on a service to see its progress. This <code>DarwinServiceRoute</code> would be created automatically, containing the <code>serviceID</code> for the selected service)</li>
</ol>


<p>There is also a <code>NoRoutesRoute</code>. I&rsquo;m starting to develop an irrational dislike of optionals, so try to avoid them wherever I can. So if the user hasn&rsquo;t yet created any routes, we have a <code>NoRoutesRoute</code> there instead. (Thanks to <a href="https://twitter.com/kevinrutherford">Kevin Rutherford</a> for the inspiration to go down this route, with his &ldquo;write a program with no if statements&rdquo; kata)</p>

<p>We need something to manage our collection of routes, and that&rsquo;s in the <code>RouteManager</code>. The user&rsquo;s <em>explicit</em> routes are stored in a collection, but we also allow other routes to pushed to form a stack, so the user can drill-down from one result to another.</p>

<p>This might seem complex, but it allows the user to manage scenarios like this:</p>

<ul>
<li>User travelling from A to B, then B to C</li>
<li>User creates explicit routes &ldquo;A to B&rdquo; and &ldquo;B to C&rdquo;</li>
<li>When starting their journey, they select route &ldquo;A to B&rdquo; to see if their service is on-time</li>
<li>Then they tap on the <em>service</em> to create an implicit Service route, which is popped onto the stack. They use this to track the progress of the service they&rsquo;re travelling on</li>
<li>But they also want to see if the &ldquo;B to C&rdquo; service is running OK</li>
<li>So they select the &ldquo;B to C&rdquo; route, and tap on a service to create a second implicit Service route, which is popped onto <em>that</em> stack</li>
<li>Then they can switch between stacks, to keep track of both <em>services</em></li>
</ul>


<p><script src="/javascripts/mermaid.min.js"></script><div class="mermaid">
graph LR
RM[RouteManager]&ndash;>E1[&ldquo;Explicit route 1<br/>(example: A to B)&rdquo;]
RM[RouteManager]&ndash;>E2[&ldquo;Explicit route 2<br/>(example: B to C)&rdquo;]
subgraph stack
E2&ndash;>I2[&ldquo;Implicit pushed route<br/>(example: 08:45 service from B to C)&rdquo;]
end
subgraph stack
E1&ndash;>I1[&ldquo;Implicit pushed route<br/>(example: 08:00 service from A to B)&rdquo;]
end
</div></p>

<p>This collection of stacks is stored in shared <code>UserDefaults</code>, so you could push a new route using the iPhone and then view its results on the Apple Watch.</p>

<p><strong>Next, we&rsquo;ll need to get fetch data from an API</strong> for each type of route using <code>Entity</code> types which can fetch a particular kind of data. Right now there are two, but there could be more in the future:</p>

<dl>
<dt><code>DarwinDeparturesEntity</code></dt>
<dd>gets OpenLDBWS departure boards for services between two stations (departures from station A calling at station B)</dd>
<dt><code>DarwinServiceEntity</code></dt>
<dd>gets OpenLDBWS service information (which returns the arrival/departure times for a service at each calling-point)</dd>
</dl>

<p><strong>Which brings us to <em>results</em>.</strong> Each type of route has a corresponding <code>ResultSet</code> containing a collection of <code>Result</code> objects. Those <code>Result</code> objects can represent either a <em>service departing from a station</em>, or a <em>calling point for a single service</em>. And - to enable the user to drill-down - each <code>Result</code> can have provide a child <code>Route</code>, which defines the next query.</p>

<p>There are three other <code>ResultSet</code> objects:</p>

<dl>
<dt><code>NoRoutesResultSet</code></dt>
<dd>this is used when there are no routes defined in the app</dd>
<dt><code>LoadingResultSet</code></dt>
<dd>this is returned from Entities when they&rsquo;re fetching data for the first time</dd>
<dt><code>ErrorResultSet</code></dt>
<dd>returned from Entities if an error occurred while fetching or parsing data</dd>
</dl>

<p>With these three extra <code>ResultSet</code> objects I can define the Entity&rsquo;s <code>resultSet</code> property as non-optional:</p>

<p><figure class='code'><figcaption><span>Entity.swift </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">public</span> <span class="k">protocol</span> <span class="n">Entity</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">resultSet</span><span class="p">:</span> <span class="n">ResultSet</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In the <a href="/nearly-departed-rewrite-storage-and-sync/">next post</a>, I&rsquo;ll describe how route definitions are stored, and how they&rsquo;re synchronised between iPhone and Watch.</p>
]]></content>
  </entry>
  
</feed>
